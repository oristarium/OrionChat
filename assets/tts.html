<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="icon.ico" />
    <title>TTS Only</title>
    <style>
        body {
            margin: 0;
            padding: 0px;
            background: transparent;
            font-family: Arial, sans-serif;
            color: white;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            min-height: 100vh;
            overflow: hidden;
        }

        .avatar-container {
            width: 65vh;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .message-bubble {
            position: absolute;
            bottom: 100%;
            margin-bottom: 1rem;
            max-height: 50vh;
            width: fit-content;
            background-color: rgba(255, 255, 255, 0.9);
            color: black;
            padding: .5em;
            border-radius: 0.5em;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s, transform 0.3s;
            font-size: 3.6vh;
            font-weight: bold;
        }

        .message-bubble.show {
            opacity: 1;
            transform: translateY(0);
        }

        .message-bubble::after {
            content: '';
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 20px solid rgba(255, 255, 255, 0.9);
        }

        .username {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 0.5em 1em;
            border-radius: 0.5em;
            font-weight: bold;
            margin-bottom: 0.5em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s, transform 0.3s;
            font-size: 2vh;
        }

        .username.show {
            opacity: 1;
            transform: translateY(0);
        }

        .avatar-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform-origin: bottom center;
            margin-bottom: -4px;
        }

        @keyframes talking {
            0%, 100% { transform: scale(1, 1); }
            25% { transform: scale(1.05, 0.95); }
            50% { transform: scale(0.95, 1.05); }
            75% { transform: scale(1.02, 0.98); }
        }

        .animate-talking {
            animation: talking 0.5s ease-in-out infinite;
            transform-origin: bottom center;
        }

        .watermark {
            position: fixed;
            bottom: 10px;
            left:50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 9999;
            pointer-events: none;
            user-select: none;
            content-visibility: visible !important;
            display: block !important;
            visibility: visible !important;
            opacity: 0.5 !important;
            mix-blend-mode: normal !important;
            filter: none !important;
            transform: none !important;
            clip-path: none !important;
            -webkit-clip-path: none !important;
        }

        .watermark::before {
            content: "Powered by Oristarium";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: inherit;
            border-radius: inherit;
        }
        .avatar-wrapper {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            margin: 0px;
            padding: 0px;
            width: fit-content;
            height: fit-content;
        }

        .debug-box {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            z-index: 9999;
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .debug-box.show {
            display: block;
        }

        .debug-box__header {
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid #00ff00;
        }

        .debug-box__row {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 8px;
            margin-bottom: 4px;
        }

        .debug-box__message {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .debug-box__status {
            text-align: right;
        }

        .debug-box__status--done { color: #00ff00; }
        .debug-box__status--fetching { color: #ffff00; }
        .debug-box__status--queued { color: #ff9900; }

        #avatars-wrapper {
            display: flex;
            justify-content: space-around;
            align-items: flex-end;
            width: 100%;
            min-height: 100vh;
            padding: 0 20px;
        }

        .avatar-container {
            width: 45vh;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="watermark">
        Powered by Oristarium
    </div>

    <div class="debug-box">
        <div class="debug-box__header">Message Queue: <span id="queue-count">0</span></div>
        <div id="queue-status"></div>
    </div>

    <div id="avatars-wrapper">
        <!-- Avatars will be dynamically inserted here -->
    </div>

    <template id="avatar-template">
        <div class="avatar-container" data-avatar-id="">
            <div class="message-bubble"></div>
            <div class="username"></div>
            <div class="avatar-wrapper">
                <img class="avatar-image" src="" alt="Avatar">
            </div>
        </div>
    </template>

    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script>
        // Constants and Element References
        const ELEMENTS = {
            $avatarsWrapper: $('#avatars-wrapper'),
            $avatarTemplate: $('#avatar-template'),
            $debugQueueCount: $('#queue-count'),
            $debugQueueStatus: $('#queue-status'),
            $debugBox: $('.debug-box')
        };

        // Add debug mode initialization
        const urlParams = new URLSearchParams(window.location.search);
        const debugMode = urlParams.has('debug') && (urlParams.get('debug') === '' || urlParams.get('debug') === 'true');

        // Show debug box if in debug mode
        if (debugMode) {
            ELEMENTS.$debugBox.addClass('show');
            console.log('Debug mode enabled');
        }

        class Avatar {
            constructor(data) {
                this.id = data.id;
                this.name = data.name;
                this.states = data.states;
                this.voices = data.tts_voices;
                this.element = null;
                this.audioPlayer = new Audio();
                this.setupAudioPlayer();
            }

            setupAudioPlayer() {
                $(this.audioPlayer)
                    .on('play', () => {
                        console.log(`Avatar ${this.id} started speaking`);
                        this.updateUIState(true);
                    })
                    .on('ended', () => {
                        console.log(`Avatar ${this.id} finished speaking`);
                        this.updateUIState(false);
                    })
                    .on('pause', () => {
                        console.log(`Avatar ${this.id} paused speaking`);
                        this.updateUIState(false);
                    })
                    .on('error', () => {
                        console.error(`Avatar ${this.id} audio error`);
                        this.updateUIState(false);
                    });
            }

            createElements() {
                const $template = $(ELEMENTS.$avatarTemplate.html());
                const $container = $template.filter('.avatar-container');
                $container.attr('data-avatar-id', this.id);
                
                this.element = {
                    $container: $container,
                    $messageBubble: $container.find('.message-bubble'),
                    $username: $container.find('.username'),
                    $avatar: $container.find('.avatar-image'),
                    $avatarWrapper: $container.find('.avatar-wrapper')
                };

                this.element.$avatar.attr('src', this.states.idle);
                return $container;
            }

            updateUIState(isPlaying) {
                this.element.$avatar.attr('src', this.states[isPlaying ? 'talking' : 'idle']);
                this.element.$avatarWrapper.toggleClass('animate-talking', isPlaying);
                this.element.$messageBubble.toggleClass('show', isPlaying);
                this.element.$username.toggleClass('show', isPlaying);
            }

            getRandomVoice() {
                return this.voices[Math.floor(Math.random() * this.voices.length)];
            }
        }

        class AvatarManager {
            constructor() {
                this.avatars = new Map();
                this.messageQueue = [];
                this.isProcessing = false;
                this.audioCache = new Map();
                this.lastPlayedMessageId = null;
            }

            async initialize() {
                try {
                    const { avatars } = await $.get('/api/avatars/active');
                    this.updateAvatars(avatars);
                } catch (error) {
                    console.error('Error initializing avatars:', error);
                }
            }

            updateAvatars(avatarsData) {
                ELEMENTS.$avatarsWrapper.empty();
                this.avatars.clear();

                avatarsData.forEach(avatarData => {
                    const avatar = new Avatar(avatarData);
                    const $element = avatar.createElements();
                    ELEMENTS.$avatarsWrapper.append($element);
                    this.avatars.set(avatar.id, avatar);
                });
            }

            getRandomAvatar() {
                const avatars = Array.from(this.avatars.values());
                return avatars[Math.floor(Math.random() * avatars.length)];
            }

            async processTTSMessage(chatMessage) {
                // Check for duplicate consecutive message
                if (chatMessage.message_id === this.lastPlayedMessageId) {
                    console.log('Ignoring duplicate consecutive message:', chatMessage.message_id);
                    return;
                }

                // Check if this message is already in queue
                const isDuplicate = this.messageQueue.some(item => 
                    item.chatMessage.message_id === chatMessage.message_id
                );
                if (isDuplicate) {
                    console.log('Ignoring duplicate message already in queue:', chatMessage.message_id);
                    return;
                }

                // Randomly select an avatar for this message
                const selectedAvatar = this.getRandomAvatar();
                if (!selectedAvatar) {
                    console.error('No avatars available');
                    return;
                }

                // Get a random voice from the selected avatar
                const voice = selectedAvatar.getRandomVoice();
                if (!voice) {
                    console.error('No voice found for avatar:', selectedAvatar.id);
                    return;
                }

                // Add to queue
                this.messageQueue.push({
                    chatMessage,
                    avatar: selectedAvatar,
                    voice
                });
                
                this.updateDebugBox();

                if (!this.isProcessing) {
                    this.processQueue();
                }
            }

            async processQueue() {
                if (this.isProcessing || this.messageQueue.length === 0) {
                    return;
                }

                this.isProcessing = true;

                while (this.messageQueue.length > 0) {
                    const { chatMessage, avatar, voice } = this.messageQueue[0];
                    console.log(`Processing message for avatar ${avatar.id} with voice ${voice.voice_id}`);

                    const content = chatMessage.data.content;
                    const textForTTS = typeof content === 'string' 
                        ? content 
                        : (content.sanitized || content.raw || content.formatted || '');

                    if (!textForTTS.trim()) {
                        this.messageQueue.shift();
                        this.updateDebugBox();
                        continue;
                    }

                    const authorName = chatMessage.data.author.display_name 
                        || chatMessage.data.author.name 
                        || 'Anonymous';

                    // Update content
                    avatar.element.$messageBubble.text(textForTTS);
                    avatar.element.$username.text(authorName);

                    try {
                        let audio;
                        if (this.audioCache.has(chatMessage.message_id)) {
                            console.log('Using cached audio for message:', chatMessage.message_id);
                            audio = this.audioCache.get(chatMessage.message_id);
                            this.audioCache.delete(chatMessage.message_id);
                        } else {
                            console.log('Fetching TTS audio from API...');
                            audio = await this.fetchTTSAudio(textForTTS, voice.voice_id, voice.provider);
                        }

                        this.lastPlayedMessageId = chatMessage.message_id;
                        
                        // Wait for audio to finish playing
                        await new Promise((resolve, reject) => {
                            avatar.audioPlayer.src = `data:audio/mp3;base64,${audio}`;
                            
                            const onEnded = () => {
                                console.log(`Audio finished for avatar ${avatar.id}`);
                                avatar.updateUIState(false);
                                avatar.audioPlayer.onended = null;
                                resolve();
                            };

                            const onError = (error) => {
                                console.error(`Audio error for avatar ${avatar.id}:`, error);
                                avatar.updateUIState(false);
                                avatar.audioPlayer.onended = null;
                                reject(error);
                            };

                            avatar.audioPlayer.onended = onEnded;
                            avatar.audioPlayer.onerror = onError;
                            
                            avatar.audioPlayer.play().catch(onError);
                        });

                        // Add small delay between messages
                        await new Promise(resolve => setTimeout(resolve, 300));

                    } catch (error) {
                        console.error('Error processing queued TTS:', error);
                        avatar.updateUIState(false);
                    }

                    this.messageQueue.shift();
                    this.updateDebugBox();
                }

                this.isProcessing = false;
            }

            async fetchTTSAudio(text, voiceId, voiceProvider) {
                try {
                    const response = await fetch('/tts-service', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            text, 
                            voice_id: voiceId,
                            voice_provider: voiceProvider
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`TTS API error: ${response.status}`);
                    }

                    const { audio } = await response.json();
                    return audio;
                } catch (error) {
                    console.error('TTS API error:', error);
                    throw error;
                }
            }

            clearQueue() {
                // Keep the currently playing message if any
                if (this.isProcessing && this.messageQueue.length > 0) {
                    const currentMessage = this.messageQueue[0];
                    this.messageQueue = [currentMessage];
                } else {
                    this.messageQueue = [];
                }
                this.audioCache.clear();
                this.updateDebugBox();
            }

            updateDebugBox() {
                if (!debugMode) return;
                
                ELEMENTS.$debugQueueCount.text(this.messageQueue.length);
                
                const queueHTML = this.messageQueue.map((item, index) => {
                    const text = typeof item.chatMessage.data.content === 'string' 
                        ? item.chatMessage.data.content 
                        : (item.chatMessage.data.content.sanitized || 
                           item.chatMessage.data.content.raw || 
                           item.chatMessage.data.content.formatted || '');
                    
                    let status = 'queued';
                    if (index === 0 && this.isProcessing) {
                        status = this.audioCache.has(item.chatMessage.message_id) ? 'done' : 'fetching';
                    }
                    
                    return `
                        <div class="debug-box__row">
                            <div class="debug-box__message">${text.substring(0, 30)}${text.length > 30 ? '...' : ''}</div>
                            <div class="debug-box__status debug-box__status--${status}">${status}</div>
                        </div>
                    `;
                }).join('');

                ELEMENTS.$debugQueueStatus.html(queueHTML);
            }
        }

        // Initialize the application
        const avatarManager = new AvatarManager();

        // jQuery document ready handler
        $(async function() {
            await avatarManager.initialize();
            setupEventSource();
        });

        function setupEventSource() {
            const evtSource = new EventSource('/sse');
            
            evtSource.onmessage = async (event) => {
                const data = JSON.parse(event.data);

                if (data.type === 'avatar_update') {
                    avatarManager.updateAvatars(data.data.avatars);
                } else if (data.type === 'tts') {
                    await avatarManager.processTTSMessage(data.data.message);
                } else if (data.type === 'clear_tts') {
                    avatarManager.clearQueue();
                }
            };
        }
    </script>
</body>
</html> 