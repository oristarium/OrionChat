<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="icon.ico" />
    <title>TTS Only</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes talking {
            0%, 100% { transform: scale(1, 1); }
            25% { transform: scale(1.05, 0.95); }
            50% { transform: scale(0.95, 1.05); }
            75% { transform: scale(1.02, 0.98); }
        }

        .animate-talking {
            animation: talking 0.5s ease-in-out infinite;
            transform-origin: bottom center;
        }

        #configToggle {
            transition: transform 0.3s ease;
        }
        
        #configToggle.rotate-180 {
            transform: rotate(180deg);
        }
    </style>
</head>
<body class="m-0 p-0 bg-transparent font-sans text-white flex justify-center items-end min-h-screen overflow-hidden">
    <div class="fixed top-2.5 right-2.5 bg-black/80 text-green-500 p-2.5 rounded font-mono text-xs z-50 max-w-[300px] max-h-[200px] overflow-y-auto hidden" id="debug-box">
        <div class="mb-2 pb-1 border-b border-green-500">Message Queue: <span id="queue-count">0</span></div>
        <div id="queue-status"></div>
    </div>

    <button id="configToggle" class="fixed top-4 left-4 w-10 h-10 bg-black/80 hover:bg-black/90 text-white rounded-full shadow-lg z-[1000] flex items-center justify-center transition-transform duration-300">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
        </svg>
    </button>

    <div id="configPanel" class="fixed top-4 left-16 bg-black/80 text-white p-4 rounded shadow-lg z-[1000] hidden min-w-[600px]">
        <div class="text-sm font-bold mb-3 border-b border-white/20 pb-1">Configurer</div>
        
        <div class="grid grid-cols-3 gap-6">
            <!-- Text Settings Group -->
            <div class="space-y-4 col-span-2">
                <div class="text-xs font-semibold text-white/60 border-b border-white/10 pb-1">Text Settings</div>
                <div class="grid grid-cols-2 gap-4">
                    <!-- Message Font Size -->
                    <div class="space-y-1">
                        <label class="text-xs block text-white/80">Message Font Size</label>
                        <input 
                            type="range" 
                            id="messageFontSize" 
                            min="12" 
                            max="72" 
                            step="1" 
                            value="36" 
                            class="w-full"
                        >
                        <div class="text-xs text-white/60"><span id="messageFontSizeValue">36</span>px</div>
                    </div>

                    <!-- Author Name Font Size -->
                    <div class="space-y-1">
                        <label class="text-xs block text-white/80">Author Name Font Size</label>
                        <input 
                            type="range" 
                            id="authorFontSize" 
                            min="8" 
                            max="48" 
                            step="1" 
                            value="20" 
                            class="w-full"
                        >
                        <div class="text-xs text-white/60"><span id="authorFontSizeValue">20</span>px</div>
                    </div>

                    <!-- Message Box Padding -->
                    <div class="space-y-1">
                        <label class="text-xs block text-white/80">Message Box Padding</label>
                        <input 
                            type="range" 
                            id="messagePadding" 
                            min="0.2" 
                            max="3" 
                            step="0.1" 
                            value="0.5" 
                            class="w-full"
                        >
                        <div class="text-xs text-white/60"><span id="messagePaddingValue">0.5</span>em</div>
                    </div>
                </div>
            </div>

            <!-- Layout Settings Group -->
            <div class="space-y-4">
                <div class="text-xs font-semibold text-white/60 border-b border-white/10 pb-1">Layout Settings</div>
                
                <!-- Avatar Container Position -->
                <div class="space-y-1">
                    <label class="text-xs block text-white/80">Position</label>
                    <div class="grid grid-cols-3 gap-0.5 p-1 bg-black/40 rounded aspect-square w-24">
                        <button class="position-btn rounded hover:bg-white/20 transition-colors border border-white/10 aspect-square" data-justify="start" data-align="start"></button>
                        <button class="position-btn rounded hover:bg-white/20 transition-colors border border-white/10 aspect-square" data-justify="center" data-align="start"></button>
                        <button class="position-btn rounded hover:bg-white/20 transition-colors border border-white/10 aspect-square" data-justify="end" data-align="start"></button>
                        <button class="position-btn rounded hover:bg-white/20 transition-colors border border-white/10 aspect-square" data-justify="start" data-align="center"></button>
                        <button class="position-btn rounded hover:bg-white/20 transition-colors border border-white/10 aspect-square" data-justify="center" data-align="center"></button>
                        <button class="position-btn rounded hover:bg-white/20 transition-colors border border-white/10 aspect-square" data-justify="end" data-align="center"></button>
                        <button class="position-btn rounded hover:bg-white/20 transition-colors border border-white/10 aspect-square" data-justify="start" data-align="end"></button>
                        <button class="position-btn rounded hover:bg-white/20 transition-colors border border-white/10 aspect-square" data-justify="center" data-align="end"></button>
                        <button class="position-btn rounded hover:bg-white/20 transition-colors border border-white/10 aspect-square" data-justify="end" data-align="end"></button>
                    </div>
                </div>

                <!-- Avatar Size -->
                <div class="space-y-1">
                    <label class="text-xs block text-white/80">Avatar Size</label>
                    <input 
                        type="range" 
                        id="avatarSize" 
                        min="100" 
                        max="800" 
                        step="50" 
                        value="400" 
                        class="w-full"
                    >
                    <div class="text-xs text-white/60"><span id="avatarSizeValue">400</span>px</div>
                </div>

                <!-- Avatar Gap -->
                <div class="space-y-1">
                    <label class="text-xs block text-white/80">Avatar Gap</label>
                    <input 
                        type="range" 
                        id="avatarGap" 
                        min="-500" 
                        max="500" 
                        step="10" 
                        value="0" 
                        class="w-full"
                    >
                    <div class="text-xs text-white/60"><span id="avatarGapValue">0</span>px</div>
                </div>

                <!-- Stacking Order -->
                <div class="space-y-1">
                    <label class="text-xs block text-white/80">Stacking Order</label>
                    <button 
                        id="stackingOrderToggle" 
                        class="w-full px-3 py-2 bg-black/40 rounded text-xs text-white/80 hover:bg-white/20 transition-colors text-left flex items-center justify-between"
                        data-reversed="false"
                    >
                        <span>First Avatar on Top</span>
                        <svg class="w-4 h-4 transition-transform" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="avatars-wrapper" class="flex justify-left items-end w-full h-screen w-screen">
        <!-- Avatars will be dynamically inserted here -->
    </div>

    <template id="avatar-template">
        <div class="avatar-container relative flex flex-col items-center w-[400px] [&:nth-child(1)]:z-50 [&:nth-child(2)]:z-40 [&:nth-child(3)]:z-30 [&:nth-child(4)]:z-20 [&:nth-child(5)]:z-10" data-avatar-id="">
            <div class="message-bubble absolute bottom-full mb-4 max-h-[50vh] w-fit bg-white/90 text-black rounded-lg text-center shadow-lg translate-y-2.5 transition-all duration-300 text-[36px] font-bold opacity-0 [&.show]:opacity-100 [&.show]:translate-y-0 p-[0.5em]"></div>
            <div class="username bg-black/50 text-white px-4 py-2 rounded-lg font-bold mb-2 whitespace-nowrap overflow-hidden text-ellipsis text-center translate-y-2.5 transition-all duration-300 text-[20px] opacity-0 [&.show]:opacity-100 [&.show]:translate-y-0"></div>
            <div class="avatar-wrapper flex items-end justify-center m-0 p-0 w-fit h-fit">
                <img class="avatar-image w-full h-full object-contain origin-bottom -mb-1" src="" alt="Avatar">
            </div>
            <div class="absolute bottom-1 left-1/2 -translate-x-1/2 bg-black/70 text-white px-2.5 py-1.5 rounded text-xs pointer-events-none select-none opacity-75 flex items-center gap-1">
                Powered by 
                <img 
                    src="https://ucarecdn.com/87bb45de-4a95-40d7-83c6-73866de942d5/-/crop/5518x2493/1408,2949/-/preview/50x50/" 
                    alt="Oristarium" 
                    class="object-contain -mb-1"
                >
            </div>
        </div>
    </template>

    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script>
        // Constants and Element References
        const ELEMENTS = {
            $avatarsWrapper: $('#avatars-wrapper'),
            $avatarTemplate: $('#avatar-template'),
            $debugQueueCount: $('#queue-count'),
            $debugQueueStatus: $('#queue-status'),
            $debugBox: $('.debug-box')
        };

        // Add debug mode initialization
        const urlParams = new URLSearchParams(window.location.search);
        const debugMode = urlParams.has('debug') && (urlParams.get('debug') === '' || urlParams.get('debug') === 'true');

        // Show debug box if in debug mode
        if (debugMode) {
            ELEMENTS.$debugBox.addClass('show');
            console.log('Debug mode enabled');
        }

        class Avatar {
            constructor(data) {
                this.id = data.id;
                this.name = data.name;
                this.states = data.states;
                this.voices = data.tts_voices;
                this.element = null;
                this.audioPlayer = new Audio();
                this.setupAudioPlayer();
            }

            setupAudioPlayer() {
                $(this.audioPlayer)
                    .on('play', () => {
                        console.log(`Avatar ${this.id} started speaking`);
                        this.updateUIState(true);
                    })
                    .on('ended', () => {
                        console.log(`Avatar ${this.id} finished speaking`);
                        this.updateUIState(false);
                    })
                    .on('pause', () => {
                        console.log(`Avatar ${this.id} paused speaking`);
                        this.updateUIState(false);
                    })
                    .on('error', () => {
                        console.error(`Avatar ${this.id} audio error`);
                        this.updateUIState(false);
                    });
            }

            createElements() {
                const $template = $(ELEMENTS.$avatarTemplate.html());
                const $container = $template.filter('.avatar-container');
                $container.attr('data-avatar-id', this.id);
                
                // Get values from inputs (which will have loaded values from localStorage)
                const messageFontSize = $('#messageFontSize').val();
                const authorFontSize = $('#authorFontSize').val();
                const avatarSize = $('#avatarSize').val();
                const avatarGap = $('#avatarGap').val();
                const messagePadding = $('#messagePadding').val();
                const isStackingReversed = $('#stackingOrderToggle').data('reversed');
                
                // Apply configuration including stacking order
                if (isStackingReversed) {
                    $container.removeClass('[&:nth-child(1)]:z-50 [&:nth-child(2)]:z-40 [&:nth-child(3)]:z-30 [&:nth-child(4)]:z-20 [&:nth-child(5)]:z-10')
                             .addClass('[&:nth-child(1)]:z-10 [&:nth-child(2)]:z-20 [&:nth-child(3)]:z-30 [&:nth-child(4)]:z-40 [&:nth-child(5)]:z-50');
                }
                
                // Apply configuration
                $container.css('width', `${avatarSize}px`);
                $container.css('marginRight', `${avatarGap}px`);
                $container.find('.message-bubble').css({
                    'fontSize': `${messageFontSize}px`,
                    'padding': `${messagePadding}em`
                });
                $container.find('.username').css('fontSize', `${authorFontSize}px`);
                
                // Check if we're in configuration mode
                const isConfiguring = !$('#configPanel').hasClass('hidden');
                if (isConfiguring) {
                    $container.find('.message-bubble')
                        .text("Sample message text here. Adjust the size using the controls!")
                        .addClass('show');
                    $container.find('.username')
                        .text("Sample Username")
                        .addClass('show');
                }
                
                this.element = {
                    $container: $container,
                    $messageBubble: $container.find('.message-bubble'),
                    $username: $container.find('.username'),
                    $avatar: $container.find('.avatar-image'),
                    $avatarWrapper: $container.find('.avatar-wrapper')
                };

                this.element.$avatar.attr('src', this.states.idle);
                return $container;
            }

            updateUIState(isPlaying) {
                this.element.$avatar.attr('src', this.states[isPlaying ? 'talking' : 'idle']);
                this.element.$avatarWrapper.toggleClass('animate-talking', isPlaying);
                this.element.$messageBubble.toggleClass('show', isPlaying);
                this.element.$username.toggleClass('show', isPlaying);
            }

            getRandomVoice() {
                return this.voices[Math.floor(Math.random() * this.voices.length)];
            }
        }

        class AvatarManager {
            constructor() {
                this.avatars = new Map();
                this.messageQueue = [];
                this.isProcessing = false;
                this.audioCache = new Map();
                this.lastPlayedMessageId = null;
            }

            async initialize() {
                try {
                    const { avatars } = await $.get('/api/avatars/active');
                    this.updateAvatars(avatars);
                } catch (error) {
                    console.error('Error initializing avatars:', error);
                }
            }

            updateAvatars(avatarsData) {
                ELEMENTS.$avatarsWrapper.empty();
                this.avatars.clear();

                avatarsData.forEach(avatarData => {
                    const avatar = new Avatar(avatarData);
                    const $element = avatar.createElements();
                    ELEMENTS.$avatarsWrapper.append($element);
                    this.avatars.set(avatar.id, avatar);
                });
            }

            getRandomAvatar() {
                const avatars = Array.from(this.avatars.values());
                return avatars[Math.floor(Math.random() * avatars.length)];
            }

            async processTTSMessage(chatMessage) {
                // Check for duplicate consecutive message
                if (chatMessage.message_id === this.lastPlayedMessageId) {
                    console.log('Ignoring duplicate consecutive message:', chatMessage.message_id);
                    return;
                }

                // Check if this message is already in queue
                const isDuplicate = this.messageQueue.some(item => 
                    item.chatMessage.message_id === chatMessage.message_id
                );
                if (isDuplicate) {
                    console.log('Ignoring duplicate message already in queue:', chatMessage.message_id);
                    return;
                }

                // Randomly select an avatar for this message
                const selectedAvatar = this.getRandomAvatar();
                if (!selectedAvatar) {
                    console.error('No avatars available');
                    return;
                }

                // Get a random voice from the selected avatar
                const voice = selectedAvatar.getRandomVoice();
                if (!voice) {
                    console.error('No voice found for avatar:', selectedAvatar.id);
                    return;
                }

                // Add to queue
                this.messageQueue.push({
                    chatMessage,
                    avatar: selectedAvatar,
                    voice
                });
                
                this.updateDebugBox();

                if (!this.isProcessing) {
                    this.processQueue();
                }
            }

            async processQueue() {
                if (this.isProcessing || this.messageQueue.length === 0) {
                    return;
                }

                this.isProcessing = true;

                while (this.messageQueue.length > 0) {
                    const { chatMessage, avatar, voice } = this.messageQueue[0];
                    console.log(`Processing message for avatar ${avatar.id} with voice ${voice.voice_id}`);

                    const content = chatMessage.data.content;
                    const textForTTS = typeof content === 'string' 
                        ? content 
                        : (content.sanitized || content.raw || content.formatted || '');

                    if (!textForTTS.trim()) {
                        this.messageQueue.shift();
                        this.updateDebugBox();
                        continue;
                    }

                    const authorName = chatMessage.data.author.display_name 
                        || chatMessage.data.author.name 
                        || 'Anonymous';

                    // Update content
                    avatar.element.$messageBubble.text(textForTTS);
                    avatar.element.$username.text(authorName);

                    try {
                        let audio;
                        if (this.audioCache.has(chatMessage.message_id)) {
                            console.log('Using cached audio for message:', chatMessage.message_id);
                            audio = this.audioCache.get(chatMessage.message_id);
                            this.audioCache.delete(chatMessage.message_id);
                        } else {
                            console.log('Fetching TTS audio from API...');
                            audio = await this.fetchTTSAudio(textForTTS, voice.voice_id, voice.provider);
                        }

                        this.lastPlayedMessageId = chatMessage.message_id;
                        
                        // Wait for audio to finish playing
                        await new Promise((resolve, reject) => {
                            avatar.audioPlayer.src = `data:audio/mp3;base64,${audio}`;
                            
                            const onEnded = () => {
                                console.log(`Audio finished for avatar ${avatar.id}`);
                                avatar.updateUIState(false);
                                avatar.audioPlayer.onended = null;
                                resolve();
                            };

                            const onError = (error) => {
                                console.error(`Audio error for avatar ${avatar.id}:`, error);
                                avatar.updateUIState(false);
                                avatar.audioPlayer.onended = null;
                                reject(error);
                            };

                            avatar.audioPlayer.onended = onEnded;
                            avatar.audioPlayer.onerror = onError;
                            
                            avatar.audioPlayer.play().catch(onError);
                        });

                        // Add small delay between messages
                        await new Promise(resolve => setTimeout(resolve, 300));

                    } catch (error) {
                        console.error('Error processing queued TTS:', error);
                        avatar.updateUIState(false);
                    }

                    this.messageQueue.shift();
                    this.updateDebugBox();
                }

                this.isProcessing = false;
            }

            async fetchTTSAudio(text, voiceId, voiceProvider) {
                try {
                    const response = await fetch('/tts-service', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            text, 
                            voice_id: voiceId,
                            voice_provider: voiceProvider
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`TTS API error: ${response.status}`);
                    }

                    const { audio } = await response.json();
                    return audio;
                } catch (error) {
                    console.error('TTS API error:', error);
                    throw error;
                }
            }

            clearQueue() {
                // Keep the currently playing message if any
                if (this.isProcessing && this.messageQueue.length > 0) {
                    const currentMessage = this.messageQueue[0];
                    this.messageQueue = [currentMessage];
                } else {
                    this.messageQueue = [];
                }
                this.audioCache.clear();
                this.updateDebugBox();
            }

            updateDebugBox() {
                if (!debugMode) return;
                
                ELEMENTS.$debugQueueCount.text(this.messageQueue.length);
                
                const queueHTML = this.messageQueue.map((item, index) => {
                    const text = typeof item.chatMessage.data.content === 'string' 
                        ? item.chatMessage.data.content 
                        : (item.chatMessage.data.content.sanitized || 
                           item.chatMessage.data.content.raw || 
                           item.chatMessage.data.content.formatted || '');
                    
                    let status = 'queued';
                    if (index === 0 && this.isProcessing) {
                        status = this.audioCache.has(item.chatMessage.message_id) ? 'done' : 'fetching';
                    }
                    
                    return `
                        <div class="debug-box__row">
                            <div class="debug-box__message">${text.substring(0, 30)}${text.length > 30 ? '...' : ''}</div>
                            <div class="debug-box__status debug-box__status--${status}">${status}</div>
                        </div>
                    `;
                }).join('');

                ELEMENTS.$debugQueueStatus.html(queueHTML);
            }
        }

        // Initialize the application
        const avatarManager = new AvatarManager();

        // jQuery document ready handler
        $(async function() {
            await avatarManager.initialize();
            setupEventSource();
        });

        function setupEventSource() {
            const evtSource = new EventSource('/sse');
            
            evtSource.onmessage = async (event) => {
                const data = JSON.parse(event.data);

                if (data.type === 'avatar_update') {
                    avatarManager.updateAvatars(data.data.avatars);
                } else if (data.type === 'tts') {
                    await avatarManager.processTTSMessage(data.data.message);
                } else if (data.type === 'clear_tts') {
                    avatarManager.clearQueue();
                }
            };
        }

        // Configuration panel functionality
        function setupConfigPanel() {
            const configInputs = {
                messageFontSize: {
                    input: $('#messageFontSize'),
                    value: $('#messageFontSizeValue'),
                    apply: (value) => {
                        $('.message-bubble').css('fontSize', `${value}px`);
                    }
                },
                authorFontSize: {
                    input: $('#authorFontSize'),
                    value: $('#authorFontSizeValue'),
                    apply: (value) => {
                        $('.username').css('fontSize', `${value}px`);
                    }
                },
                avatarSize: {
                    input: $('#avatarSize'),
                    value: $('#avatarSizeValue'),
                    apply: (value) => {
                        $('.avatar-container').css('width', `${value}px`);
                    }
                },
                avatarGap: {
                    input: $('#avatarGap'),
                    value: $('#avatarGapValue'),
                    apply: (value) => {
                        const justify = configInputs.containerPosition.value.justify;
                        $('.avatar-container').css({
                            'margin-left': justify === 'center' ? `${value/2}px` : 
                                          justify === 'end' ? `${value}px` : '0',
                            'margin-right': justify === 'center' ? `${value/2}px` : 
                                          justify === 'start' ? `${value}px` : '0'
                        });
                    }
                },
                messagePadding: {
                    input: $('#messagePadding'),
                    value: $('#messagePaddingValue'),
                    apply: (value) => {
                        $('.message-bubble').css('padding', `${value}em`);
                    }
                },
                containerPosition: {
                    value: { justify: 'left', align: 'end' },
                    apply: (value) => {
                        $('#avatars-wrapper').css({
                            'justify-content': value.justify,
                            'align-items': value.align
                        });
                        // Reapply gap with new justification
                        const gapValue = $('#avatarGap').val();
                        configInputs.avatarGap.apply(gapValue);
                    }
                },
                stackingOrder: {
                    value: false, // false = first on top, true = reversed
                    apply: (value) => {
                        const $avatars = $('.avatar-container');
                        if (value) {
                            // Reversed: Last avatar on top
                            $avatars.removeClass('[&:nth-child(1)]:z-50 [&:nth-child(2)]:z-40 [&:nth-child(3)]:z-30 [&:nth-child(4)]:z-20 [&:nth-child(5)]:z-10')
                                   .addClass('[&:nth-child(1)]:z-10 [&:nth-child(2)]:z-20 [&:nth-child(3)]:z-30 [&:nth-child(4)]:z-40 [&:nth-child(5)]:z-50');
                        } else {
                            // Normal: First avatar on top
                            $avatars.removeClass('[&:nth-child(1)]:z-10 [&:nth-child(2)]:z-20 [&:nth-child(3)]:z-30 [&:nth-child(4)]:z-40 [&:nth-child(5)]:z-50')
                                   .addClass('[&:nth-child(1)]:z-50 [&:nth-child(2)]:z-40 [&:nth-child(3)]:z-30 [&:nth-child(4)]:z-20 [&:nth-child(5)]:z-10');
                        }
                    }
                }
            };

            function loadConfig() {
                const savedConfig = localStorage.getItem('ttsConfig');
                if (savedConfig) {
                    const config = JSON.parse(savedConfig);
                    Object.entries(config).forEach(([key, value]) => {
                        if (configInputs[key]) {
                            if (key === 'containerPosition') {
                                configInputs[key].value = value;
                                configInputs[key].apply(value);
                                $(`.position-btn[data-justify="${value.justify}"][data-align="${value.align}"]`)
                                    .addClass('bg-white/20');
                            } else {
                                configInputs[key].input.val(value);
                                configInputs[key].value.text(value);
                                configInputs[key].apply(value);
                            }
                        }
                    });
                }
            }

            function saveConfig() {
                const config = {};
                Object.entries(configInputs).forEach(([key, control]) => {
                    if (key === 'containerPosition' || key === 'stackingOrder') {
                        // For button-based controls, save the value directly
                        config[key] = control.value;
                    } else if (control.input) {
                        // For input-based controls, save the input value
                        config[key] = control.input.val();
                    }
                });
                localStorage.setItem('ttsConfig', JSON.stringify(config));
            }

            // Load saved configuration on init
            loadConfig();

            // Update event listeners to use jQuery
            Object.entries(configInputs).forEach(([key, config]) => {
                // Only add input listeners for controls that have input elements
                if (config.input && config.value) {
                    config.input.on('input', function() {
                        const value = $(this).val();
                        config.value.text(value);
                        config.apply(value);
                        saveConfig();
                    });
                }
            });

            // Add toggle button functionality
            const $configToggle = $('#configToggle');
            const $configPanel = $('#configPanel');
            let isConfiguring = false;

            $configToggle.on('click', () => {
                isConfiguring = !isConfiguring;
                $configPanel.toggleClass('hidden', !isConfiguring);
                $configToggle.toggleClass('rotate-180', isConfiguring);
                
                // Show/hide sample text in avatars
                $('.avatar-container').each(function() {
                    const $messageBubble = $(this).find('.message-bubble');
                    const $username = $(this).find('.username');
                    
                    if (isConfiguring) {
                        $messageBubble
                            .text("Sample message text here. Adjust the size using the controls!")
                            .addClass('show');
                        $username
                            .text("Sample Username")
                            .addClass('show');
                    } else {
                        $messageBubble.removeClass('show');
                        $username.removeClass('show');
                    }
                });
            });

            // Position button handlers
            $('.position-btn').on('click', function() {
                const justify = $(this).data('justify');
                const align = $(this).data('align');
                
                // Update active state
                $('.position-btn').removeClass('bg-white/20');
                $(this).addClass('bg-white/20');
                
                // Update position
                configInputs.containerPosition.value = { justify, align };
                configInputs.containerPosition.apply({ justify, align });
                
                // Save to config
                saveConfig();
            });

            // Stacking order toggle button handlers
            $('#stackingOrderToggle').on('click', function() {
                const $this = $(this);
                const currentValue = $this.data('reversed');
                const newValue = !currentValue;
                
                // Update button state
                $this.data('reversed', newValue);
                $this.find('span').text(newValue ? 'Last Avatar on Top' : 'First Avatar on Top');
                $this.find('svg').toggleClass('rotate-180', newValue);
                
                // Update stacking order
                configInputs.stackingOrder.value = newValue;
                configInputs.stackingOrder.apply(newValue);
                
                // Save to config
                saveConfig();
            });
        }

        // Call setupConfigPanel after document is ready
        $(document).ready(function() {
            setupConfigPanel();
        });
    </script>
</body>
</html> 